<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content=""/><meta name="keyword"/><title>MoJo Monkey
-

</title><link rel="icon" href="/img/favicon.ico"/>
<link rel="stylesheet" href="/MoJi-Monkey/css/style.css">

<link rel="stylesheet" href="/MoJi-Monkey/css/helpers.css">
<script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading-wrapper" data-loading="true"><div class="loading"><span></span><span></span><span></span></div></div><div class="page" data-filter="true"><div class="head" data-show="true"><header class="head-header"><div class="head-author"><a class="head-author-link" href="/MoJi-Monkey/">MoJo Monkey</a></div><div class="head-right"><button class="bar-wrap" id="bar-wrap-toggle"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button><div class="head-item"><a class="search-button head-item-link"><i class="icon icon-search"></i></a></div><div class="head-item"><a class="head-item-link" href="/MoJi-Monkey/about">About</a></div></div></header>
<div class="menu-bar-head" id="menu-bar" data-show="false"><ul class="menu-bar-ul"><li class="menu-bar-item"><a href="/MoJi-Monkey/categories/Posts/"><span>Posts1</span></a></li><li class="menu-bar-item"><a href="/MoJi-Monkey/categories/Posts2/"><span>Posts2</span></a></li><li class="menu-bar-item  border"><a href="/MoJi-Monkey/archives"><span>Archives</span></a></li><li class="menu-bar-item"><a href="/MoJi-Monkey/tags"><span>Tags</span></a></li><li class="menu-bar-item"><a class="search-button"><span>Search</span></a></li><li class="menu-bar-item"><a href="/MoJi-Monkey/about"><span>About</span></a></li></ul></div></div><div class="main"><article class="post" id="post"><header class="post-head"><h1 class="post-title"><a class="title" href="/MoJi-Monkey/2023/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React/Scheduler/">Scheduler 源码分析</a></h1></header><div class="post-datetag"><div class="post-date"><time class="post-time" itemprop="datePublished" title="2023-09-19 19:04:53" datetime="2023-09-19T11:04:53.000Z">2023-09-19</time></div>|<div class="post-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/MoJi-Monkey/tags/getDerivedStateFormError/" rel="tag">getDerivedStateFormError</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/MoJi-Monkey/tags/react/" rel="tag">react</a></li></ul></div>|
<div class="post-visit"><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span>hits</span></div></div><div class="post-word-count">本文共2,848字。</div><div class="article-entry" itemprop="articleBody"><h1 id="普通任务的调度"><a href="#普通任务的调度" class="headerlink" title="普通任务的调度"></a>普通任务的调度</h1><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Max 31 bit integer. The max integer size in V8 for 32-bit systems.</span></span><br><span class="line"><span class="comment">// Math.pow(2, 30) - 1</span></span><br><span class="line"><span class="comment">// 0b111111111111111111111111111111</span></span><br><span class="line"><span class="keyword">var</span> maxSigned31BitInt = <span class="number">1073741823</span>; <span class="comment">// 这里取了31位有符号整数的最大值，意思是永远不会过期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Times out immediately</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span> = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// Eventually times out</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">USER_BLOCKING_PRIORITY_TIMEOUT</span> = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">NORMAL_PRIORITY_TIMEOUT</span> = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">LOW_PRIORITY_TIMEOUT</span> = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// Never times out</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IDLE_PRIORITY_TIMEOUT</span> = maxSigned31BitInt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">taskQueue</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Task</span>&gt; = []; <span class="comment">// 普通任务</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">timerQueue</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Task</span>&gt; = []; <span class="comment">// 延迟任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isHostTimeoutScheduled = <span class="literal">false</span>; <span class="comment">// 是否有延迟任务正在调度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="schedulerCallback"><a href="#schedulerCallback" class="headerlink" title="schedulerCallback"></a>schedulerCallback</h3><p>这个函数的主要目的就是调度任务</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> priorityLevel 优先级登记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback 回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> options 选项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_scheduleCallback</span>(<span class="params"></span></span><br><span class="line"><span class="params">  priorityLevel: PriorityLevel,</span></span><br><span class="line"><span class="params">  callback: Callback,</span></span><br><span class="line"><span class="params">  options?: &#123; delay: number &#125;,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Task</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="title function_">getCurrentTime</span>();<span class="comment">// performance.now()  // 获取当前时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// callback开始时间</span></span><br><span class="line">  <span class="keyword">var</span> startTime;</span><br><span class="line">  <span class="comment">// 判断是否设置delay，来修正startTime</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">&#x27;object&#x27;</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> delay = options.<span class="property">delay</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">&#x27;number&#x27;</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      startTime = currentTime + delay;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      startTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="comment">// 根据优先级等级，设置timeout</span></span><br><span class="line">  <span class="keyword">switch</span> (priorityLevel) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ImmediatePriority</span>:</span><br><span class="line">      timeout = <span class="variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span>; <span class="comment">// -1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">UserBlockingPriority</span>:</span><br><span class="line">      timeout = <span class="variable constant_">USER_BLOCKING_PRIORITY_TIMEOUT</span>; <span class="comment">// 250</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IdlePriority</span>:</span><br><span class="line">      <span class="comment">//  maxSigned31BitInt = 1073741823;</span></span><br><span class="line">      <span class="comment">// IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; </span></span><br><span class="line">      <span class="comment">// 1073741823是31位有符号整数的最大值，所以用来表示空闲优先级的超时时间，意味着这些任务永远不会超时，只有在浏览器完全空闲时才会执行。</span></span><br><span class="line">      timeout = <span class="variable constant_">IDLE_PRIORITY_TIMEOUT</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LowPriority</span>:</span><br><span class="line">      timeout = <span class="variable constant_">LOW_PRIORITY_TIMEOUT</span>; <span class="comment">// 10000</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NormalPriority</span>:</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      timeout = <span class="variable constant_">NORMAL_PRIORITY_TIMEOUT</span>; <span class="comment">// 5000</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始时间+延迟时间， 就是过期时间</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = startTime + timeout;</span><br><span class="line">  <span class="comment">// 创建新任务</span></span><br><span class="line">  <span class="keyword">var</span> <span class="attr">newTask</span>: <span class="title class_">Task</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: taskIdCounter++, <span class="comment">// 任务id</span></span><br><span class="line">    callback, <span class="comment">// 任务具体要做的内容</span></span><br><span class="line">    priorityLevel, <span class="comment">// 任务优先级</span></span><br><span class="line">    startTime, <span class="comment">// 任务开始时间</span></span><br><span class="line">    expirationTime, <span class="comment">// 任务过期时间</span></span><br><span class="line">    <span class="attr">sortIndex</span>: -<span class="number">1</span>, <span class="comment">//  用于小顶堆排序（一阵算法，可以始终从任务队列中，拿出最优先的任务），进行排序的索引</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">    newTask.<span class="property">isQueued</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">    <span class="comment">// This is a delayed task.</span></span><br><span class="line">    <span class="comment">// 开始时间大于当前时间，就是延迟任务</span></span><br><span class="line"></span><br><span class="line">    newTask.<span class="property">sortIndex</span> = startTime;</span><br><span class="line">    <span class="comment">// 将延迟任务推入到 timerQueue 队列</span></span><br><span class="line">    <span class="title function_">push</span>(timerQueue, newTask);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">peek</span>(taskQueue) === <span class="literal">null</span> &amp;&amp; newTask === <span class="title function_">peek</span>(timerQueue)) &#123;</span><br><span class="line">      <span class="comment">// All tasks are delayed, and this is the task with the earliest delay.</span></span><br><span class="line">      <span class="comment">// 当 普通队列执行完毕，并且延迟队列还有任务，取出延迟队列的任务给当前的任务</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isHostTimeoutScheduled) &#123; </span><br><span class="line">        <span class="comment">// Cancel an existing timeout.</span></span><br><span class="line">        <span class="title function_">cancelHostTimeout</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostTimeoutScheduled = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Schedule a timeout.</span></span><br><span class="line">      <span class="comment">// 调度一个延迟任务</span></span><br><span class="line">      <span class="title function_">requestHostTimeout</span>(handleTimeout, startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当前任务不是延迟任务， 把当前任务推入到普通任务队列</span></span><br><span class="line">    newTask.<span class="property">sortIndex</span> = expirationTime;</span><br><span class="line">    <span class="title function_">push</span>(taskQueue, newTask);</span><br><span class="line">    <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">      <span class="title function_">markTaskStart</span>(newTask, currentTime);</span><br><span class="line">      newTask.<span class="property">isQueued</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Schedule a host callback, if needed. If we&#x27;re already performing work,</span></span><br><span class="line">    <span class="comment">// wait until the next time we yield.</span></span><br><span class="line">    <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 开始普通任务的调度</span></span><br><span class="line">      <span class="title function_">requestHostCallback</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 对外返回任务</span></span><br><span class="line">  <span class="keyword">return</span> newTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要注意几个关键点</p>
<ol>
<li><p>任务的调度，主要有两个队列，react内部用了小顶堆算法，进行任务的调度</p>
<ul>
<li>taskQueue,存放普通任务，最终调用 <strong>requestHostCallback(flushWork)</strong></li>
<li>timerQueue, 存放延迟任务，最终调用 <strong>requestHostTimeout(handleTimeout, startTime - currentTime);</strong></li>
</ul>
</li>
<li><p>根据传入的PriorityLevel，来决定任务的优先级, 并进行timeout的设置。</p>
<ul>
<li>IMMEDIATE_PRIORITY_TIMEOUT &lt;  currentTime &lt; USER_BLOCKING_PRIORITY_TIMEOUT &lt; NORMAL_PRIORITY_TIMEOUT &lt; LOW_PRIORITY_TIMEOUT &lt; IDLE_PRIORITY_TIMEOUT</li>
</ul>
</li>
</ol>
<h2 id="requestHostCallback-和-schedulePerformWorkUntilDeadline"><a href="#requestHostCallback-和-schedulePerformWorkUntilDeadline" class="headerlink" title="requestHostCallback 和 schedulePerformWorkUntilDeadline"></a>requestHostCallback 和 schedulePerformWorkUntilDeadline</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通任务的调度执行，实际上是调用 schedulePerformWorkUntilDeadline</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requestHostCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">schedulePerformWorkUntilDeadline</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// schedulePerformWorkUntilDeadline 初始化是undefined，根据环境来决定用什么方法生成宏任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 就是setTimeOut</span></span><br><span class="line"><span class="keyword">const</span> localSetTimeout = <span class="keyword">typeof</span> <span class="built_in">setTimeout</span> === <span class="string">&#x27;function&#x27;</span> ? <span class="built_in">setTimeout</span> : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> localSetImmediate =</span><br><span class="line">  <span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> ? setImmediate : <span class="literal">null</span>; <span class="comment">// IE and Node.js + jsdom</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> schedulePerformWorkUntilDeadline;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> localSetImmediate === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// Node.js and old IE. </span></span><br><span class="line">  <span class="comment">// https://github.com/facebook/react/issues/20756</span></span><br><span class="line">   <span class="comment">// node和老的IE，用的是 setImmediate</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">localSetImmediate</span>(performWorkUntilDeadline);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">MessageChannel</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// DOM and Worker environments.</span></span><br><span class="line">  <span class="comment">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span></span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line">  <span class="keyword">const</span> port = channel.<span class="property">port2</span>;</span><br><span class="line">  channel.<span class="property">port1</span>.<span class="property">onmessage</span> = performWorkUntilDeadline;</span><br><span class="line">  <span class="comment">// 大部分是用postMessage</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    port.<span class="title function_">postMessage</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// We should only fallback here in non-browser environments.</span></span><br><span class="line">  <span class="comment">// 剩下的，就是用 setTimeOut进行兜底</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// $FlowFixMe[not-a-function] nullable value</span></span><br><span class="line">    <span class="title function_">localSetTimeout</span>(performWorkUntilDeadline, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>requestHostCallback主要就是调用了 <strong>schedulePerformWorkUntilDeadline</strong></li>
<li>schedulePerformWorkUntilDeadline 会根据宿主环境不同，而采用对应的宏任务方式，但大部分场景都是MessageChannel</li>
</ol>
<h2 id="performWorkUntilDeadline"><a href="#performWorkUntilDeadline" class="headerlink" title="performWorkUntilDeadline"></a>performWorkUntilDeadline</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法主要是根据条件，调用flushWork</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">performWorkUntilDeadline</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (isMessageLoopRunning) &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="keyword">const</span> currentTime = <span class="title function_">getCurrentTime</span>(); </span><br><span class="line">    <span class="comment">// 全局变量，默认值为-1</span></span><br><span class="line">    <span class="comment">// 用来测量任务的执行时间，从而能够知道主线程被阻塞了多久</span></span><br><span class="line">    startTime = currentTime;  </span><br><span class="line">    <span class="keyword">let</span> hasMoreWork = <span class="literal">true</span>; <span class="comment">// 还有需要做的任务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是true，代表工作没做完</span></span><br><span class="line">      <span class="comment">// false，代表没有人任务</span></span><br><span class="line">      hasMoreWork = <span class="title function_">flushWork</span>(currentTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMoreWork) &#123;</span><br><span class="line">        <span class="comment">// If there&#x27;s more work, schedule the next message event at the end</span></span><br><span class="line">        <span class="comment">// of the preceding one.</span></span><br><span class="line">        <span class="comment">// 如果还有任务，就调用 messageChannel 进行一个message 事件的调度，就将任务放入到任务队列里面</span></span><br><span class="line">        <span class="title function_">schedulePerformWorkUntilDeadline</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果做完，就将 isMessageLoopRunning 这个表示 是否有人物正在调度 的状态改为 false</span></span><br><span class="line">        isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Yielding to the browser will give it a chance to paint, so we can</span></span><br><span class="line">  <span class="comment">// reset this.</span></span><br><span class="line">  needsPaint = <span class="literal">false</span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>performWorkUntilDeadline 主要还是根据条件，调用flushWork，并返回一个Boole，来判断是否还有任务需要做，如果有，就继续调用schedulePerformWorkUntilDeadline，否则，就将 isMessageLoopRunning 这个表示 是否有人物正在调度 的状态改为 false</li>
</ul>
<h2 id="flushWork-workLoop"><a href="#flushWork-workLoop" class="headerlink" title="flushWork &amp;&amp; workLoop"></a>flushWork &amp;&amp; workLoop</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialTime 执行当前任务时，开始执行的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushWork</span>(<span class="params">initialTime: number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">    <span class="title function_">markSchedulerUnsuspended</span>(initialTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;ll need a host callback the next time work is scheduled.</span></span><br><span class="line">  isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">    <span class="comment">// We scheduled a timeout but it&#x27;s no longer needed. Cancel it.</span></span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="title function_">cancelHostTimeout</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isPerformingWork = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 该方法的核心，调用workLoop进行事件循环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">workLoop</span>(initialTime);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-call] found when upgrading Flow</span></span><br><span class="line">          <span class="title function_">markTaskErrored</span>(currentTask, currentTime);</span><br><span class="line">          <span class="comment">// $FlowFixMe[incompatible-use] found when upgrading Flow</span></span><br><span class="line">          currentTask.<span class="property">isQueued</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No catch in prod code path.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">workLoop</span>(initialTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 讲时间记录在 eventLog里</span></span><br><span class="line">    currentTask = <span class="literal">null</span>;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    isPerformingWork = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">      <span class="keyword">const</span> currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line">      <span class="title function_">markSchedulerSuspended</span>(currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialTime 当前任务开始执行的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params">initialTime: number</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentTime = initialTime;</span><br><span class="line">  <span class="comment">// 遍历timerQueue，判断是否有已经到期了的任务，如果有，将这个任务放入到taskQueue,以便于下一次继续执行，这个方法可以保证taskQueue中的任务，都是按照优先级和过期时间排序的。</span></span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">// 从taskqueue取一个任务出来</span></span><br><span class="line">  currentTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    <span class="comment">// 如果当前的任务不为空</span></span><br><span class="line">    currentTask !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果当前任务的过期时间，&gt; 当前任务的时间，说明见任务还没有过期</span></span><br><span class="line">    <span class="comment">// shouldYieldToHost 是否应该暂停，归还主线程</span></span><br><span class="line">    <span class="comment">// 跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> (currentTask.<span class="property">expirationTime</span> &gt; currentTime &amp;&amp; <span class="title function_">shouldYieldToHost</span>()) &#123;</span><br><span class="line">      <span class="comment">// This currentTask hasn&#x27;t expired, and we&#x27;ve reached the deadline.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有进入到上面的逻辑，就说明进入到过期时间，并且有剩余的时间来执行，</span></span><br><span class="line">    <span class="keyword">const</span> callback = currentTask.<span class="property">callback</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      currentTask.<span class="property">callback</span> = <span class="literal">null</span>;</span><br><span class="line">      currentPriorityLevel = currentTask.<span class="property">priorityLevel</span>;</span><br><span class="line">      <span class="keyword">const</span> didUserCallbackTimeout = currentTask.<span class="property">expirationTime</span> &lt;= currentTime;</span><br><span class="line">      <span class="comment">// 信息收集，用于性能分析</span></span><br><span class="line">      <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">        <span class="title function_">markTaskRun</span>(currentTask, currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 任务执行</span></span><br><span class="line">      <span class="keyword">const</span> continuationCallback = <span class="title function_">callback</span>(didUserCallbackTimeout);</span><br><span class="line">      currentTime = <span class="title function_">getCurrentTime</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// If a continuation is returned, immediately yield to the main thread</span></span><br><span class="line">        <span class="comment">// regardless of how much time is left in the current time slice.</span></span><br><span class="line">        currentTask.<span class="property">callback</span> = continuationCallback;</span><br><span class="line">        <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">          <span class="title function_">markTaskYield</span>(currentTask, currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">          <span class="comment">// 标记当前任务完成，并触发对应的监听器</span></span><br><span class="line">          <span class="title function_">markTaskCompleted</span>(currentTask, currentTime);</span><br><span class="line">          currentTask.<span class="property">isQueued</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentTask === <span class="title function_">peek</span>(taskQueue)) &#123;</span><br><span class="line">          <span class="title function_">pop</span>(taskQueue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是function，无法执行，则弹出任务</span></span><br><span class="line">      <span class="title function_">pop</span>(taskQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再从taskQueue里拿出一个任务</span></span><br><span class="line">    currentTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return whether there&#x27;s additional work</span></span><br><span class="line">  <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果不为空，则代表还有任务，则返回true，让外部的 hasMoreWork 拿到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 说明 taskQueue 普通任务队列为空，则从 timerQueue里获取 延迟 任务</span></span><br><span class="line">    <span class="keyword">const</span> firstTimer = <span class="title function_">peek</span>(timerQueue);</span><br><span class="line">    <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果timerQueue有任务，则执行延迟队列的任务</span></span><br><span class="line">      <span class="title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="property">startTime</span> - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>flushWork 主要是调用 workLoop</li>
<li>workLoop 主要是遍历taskQueue，执行任务，如果任务执行完毕，就从taskQueue里面取出一个任务，继续执行，直到taskQueue为空，再从timerQueue里面取出一个任务，继续执行，直到timerQueue为空，就结束了。</li>
</ul>
<h2 id="shouldYieldToHost"><a href="#shouldYieldToHost" class="headerlink" title="shouldYieldToHost"></a>shouldYieldToHost</h2><p>这个方法主要就是用来判断是否要归还主线程，让浏览器进行更高优先级的任务。值得注意的是，虽然一帧有16ms，但是React内部是以5ms作为一个单位的时间切片进行循环检查。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shouldYieldToHost</span>(<span class="params"></span>): boolean &#123;</span><br><span class="line">  <span class="comment">// getCurrentTime 这个是获取的当前的时间</span></span><br><span class="line">  <span class="comment">// startTime 全局变量，一开始是 -1， 之后任务开始时，将任务开始的时间赋值给它。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timeElapsed = <span class="title function_">getCurrentTime</span>() - startTime;</span><br><span class="line">  <span class="comment">// frameInterval 默认是5ms， 是每个任务的时间切片，也就是每个任务最多可以连续执行多久。</span></span><br><span class="line">  <span class="comment">// 如果小于5ms，则没有超时</span></span><br><span class="line">  <span class="keyword">if</span> (timeElapsed &lt; frameInterval) &#123;</span><br><span class="line">    <span class="comment">// The main thread has only been blocked for a really short amount of time;</span></span><br><span class="line">    <span class="comment">// smaller than a single frame. Don&#x27;t yield yet.</span></span><br><span class="line">    <span class="comment">// 主线程只被阻塞了很短的时间，比一帧还要段，还没有达到归还到主线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  主线程被阻塞了一段时间，需要归还给主线程，让浏览器执行更高优先级的任务。</span></span><br><span class="line">  <span class="keyword">if</span> (enableIsInputPending) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needsPaint) &#123;</span><br><span class="line">      <span class="comment">// There&#x27;s a pending paint (signaled by `requestPaint`). Yield now.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeElapsed &lt; continuousInputInterval) &#123;</span><br><span class="line">      <span class="comment">// We haven&#x27;t blocked the thread for that long. Only yield if there&#x27;s a</span></span><br><span class="line">      <span class="comment">// pending discrete input (e.g. click). It&#x27;s OK if there&#x27;s pending</span></span><br><span class="line">      <span class="comment">// continuous input (e.g. mouseover).</span></span><br><span class="line">      <span class="keyword">if</span> (isInputPending !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">isInputPending</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeElapsed &lt; maxInterval) &#123;</span><br><span class="line">      <span class="comment">// Yield if there&#x27;s either a pending discrete or continuous input.</span></span><br><span class="line">      <span class="keyword">if</span> (isInputPending !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">isInputPending</span>(continuousOptions);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve blocked the thread for a long time. Even if there&#x27;s no pending</span></span><br><span class="line">      <span class="comment">// input, there may be some other scheduled work that we don&#x27;t know about,</span></span><br><span class="line">      <span class="comment">// like a network event. Yield now.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `isInputPending` isn&#x27;t available. Yield now.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="advanceTimers"><a href="#advanceTimers" class="headerlink" title="advanceTimers"></a>advanceTimers</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历timerQueue，将已经过期的任务，插入到taskQueue任务里</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentTime </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">advanceTimers</span>(<span class="params">currentTime: number</span>) &#123;</span><br><span class="line"><span class="comment">//  从延迟任务队列，获取一个任务</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="title function_">peek</span>(timerQueue);</span><br><span class="line">  <span class="keyword">while</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果任务么有对应的callback，则直接推出</span></span><br><span class="line">    <span class="keyword">if</span> (timer.<span class="property">callback</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Timer was cancelled.</span></span><br><span class="line">      <span class="title function_">pop</span>(timerQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timer.<span class="property">startTime</span> &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// 当前任务已经超过了它的预期执行时间，已经过期。需要立即执行，</span></span><br><span class="line">      <span class="comment">// 则需要将其退出，然后push仅 taskQueue队列</span></span><br><span class="line">      <span class="comment">// Timer fired. Transfer to the task queue.</span></span><br><span class="line">      <span class="title function_">pop</span>(timerQueue);</span><br><span class="line">      timer.<span class="property">sortIndex</span> = timer.<span class="property">expirationTime</span>;</span><br><span class="line">      <span class="title function_">push</span>(taskQueue, timer);</span><br><span class="line">      <span class="comment">// 收集信息</span></span><br><span class="line">      <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">        <span class="title function_">markTaskStart</span>(timer, currentTime);</span><br><span class="line">        timer.<span class="property">isQueued</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Remaining timers are pending.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从timerQuqeue再获取一个任务进行遍历</span></span><br><span class="line">    timer = <span class="title function_">peek</span>(timerQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="延迟任务的调度"><a href="#延迟任务的调度" class="headerlink" title="延迟任务的调度"></a>延迟任务的调度</h1><h2 id="requestHostTimeout"><a href="#requestHostTimeout" class="headerlink" title="requestHostTimeout"></a>requestHostTimeout</h2><p>对延迟任务的处理，实际上就是调用setTimeOut</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback 传入的 handleTimeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ms 就是delay 时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requestHostTimeout</span>(<span class="params"></span></span><br><span class="line"><span class="params">  callback: (currentTime: number) =&gt; <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  ms: number,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 下面这个就是setTimeOut</span></span><br><span class="line">  taskTimeoutID = <span class="title function_">localSetTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="title function_">getCurrentTime</span>());</span><br><span class="line">  &#125;, ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="handleTimeout"><a href="#handleTimeout" class="headerlink" title="handleTimeout"></a>handleTimeout</h2><p>主要是将时间已经到了的延迟任务，放入普通任务队列中，然后，使用requestHostCallback 进行任务调度</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentTime 当前时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleTimeout</span>(<span class="params">currentTime: number</span>) &#123;</span><br><span class="line">    <span class="comment">// 将 是否有任务需要执行 的标志位 置为 false</span></span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 遍历 timerQueue，找出所有已经到期的任务</span></span><br><span class="line">    <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">        <span class="comment">// 从普通任务队列中取出第一个任务</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">peek</span>(taskQueue) !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 采用普通任务的调度方式调度</span></span><br><span class="line">        <span class="title function_">requestHostCallback</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 普通任务队列执行完毕，就再次从延迟任务里取一个任务出来</span></span><br><span class="line">        <span class="keyword">const</span> firstTimer = <span class="title function_">peek</span>(timerQueue);</span><br><span class="line">        <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果有任务，就采用延迟任务的调度方式调度</span></span><br><span class="line">          <span class="title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="property">startTime</span> - currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></article><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>TOC</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%99%AE%E9%80%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="post-toc-number">1.</span> <span class="post-toc-text">普通任务的调度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">全局变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#schedulerCallback"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">schedulerCallback</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#requestHostCallback-%E5%92%8C-schedulePerformWorkUntilDeadline"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">requestHostCallback 和 schedulePerformWorkUntilDeadline</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#performWorkUntilDeadline"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">performWorkUntilDeadline</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#flushWork-workLoop"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">flushWork &amp;&amp; workLoop</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#shouldYieldToHost"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">shouldYieldToHost</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#advanceTimers"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">advanceTimers</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="post-toc-number">2.</span> <span class="post-toc-text">延迟任务的调度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#requestHostTimeout"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">requestHostTimeout</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#handleTimeout"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">handleTimeout</span></a></li></ol></li></ol></nav></aside></div><footer class="footer-nav"><div class="footer"><div class="back-top" id="back-top" title="Back to top"><i class="icon icon-chevron-bar-up"></i></div><span class="footer-msg"><div><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv">?</span>
PV
</span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">?</span>
UV</span></div>

Copyright &copy;
<span class="time-divide">-</span>2023
Belial.

Power by
<a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>
and
<a href="https://github.com/Cerallin/hexo-theme-yuzu" target="_blank" rel="external nofollow" title="v3.1">Theme Yuzu</a>.</span></div></footer><script>window.config = {
  url_root: '/MoJi-Monkey/',
  meta_path: 'meta.json',
};
</script>
<script src="/MoJi-Monkey/js/clipboard/clipboard.min.js"></script>


<script src="/MoJi-Monkey/js/theme.js"></script>


<script src="/MoJi-Monkey/js/index.js"></script>

<script src="/MoJi-Monkey/js/toc.js"></script>
</div><div class="search-modal" id="search-modal" data-show="false"><div class="card"><div class="card-head"><div class="search-box"><input class="search-input" id="search-input" placeholder="search"/><div class="search-button" id="search-button"><div class="icon icon-search"></div></div></div><div class="close-button"><div class="icon icon-x"></div></div></div><div class="card-body"><div class="search-count">search.total<span id="search-count-num">0</span>search result(s) in total.</div><div class="search-result" id="search-result"></div></div></div></div></body></html>