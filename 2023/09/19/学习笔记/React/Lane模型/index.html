<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content=""/><meta name="keyword"/><title>MoJo Monkey
-

</title><link rel="icon" href="/img/favicon.ico"/>
<link rel="stylesheet" href="/MoJi-Monkey/css/style.css">

<link rel="stylesheet" href="/MoJi-Monkey/css/helpers.css">
<script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading-wrapper" data-loading="true"><div class="loading"><span></span><span></span><span></span></div></div><div class="page" data-filter="true"><div class="head" data-show="true"><header class="head-header"><div class="head-author"><a class="head-author-link" href="/MoJi-Monkey/">MoJo Monkey</a></div><div class="head-right"><button class="bar-wrap" id="bar-wrap-toggle"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button><div class="head-item"><a class="search-button head-item-link"><i class="icon icon-search"></i></a></div><div class="head-item"><a class="head-item-link" href="/MoJi-Monkey/about">About</a></div></div></header>
<div class="menu-bar-head" id="menu-bar" data-show="false"><ul class="menu-bar-ul"><li class="menu-bar-item"><a href="/MoJi-Monkey/categories/Posts/"><span>Posts1</span></a></li><li class="menu-bar-item"><a href="/MoJi-Monkey/categories/Posts2/"><span>Posts2</span></a></li><li class="menu-bar-item  border"><a href="/MoJi-Monkey/archives"><span>Archives</span></a></li><li class="menu-bar-item"><a href="/MoJi-Monkey/tags"><span>Tags</span></a></li><li class="menu-bar-item"><a class="search-button"><span>Search</span></a></li><li class="menu-bar-item"><a href="/MoJi-Monkey/about"><span>About</span></a></li></ul></div></div><div class="main"><article class="post" id="post"><header class="post-head"><h1 class="post-title"><a class="title" href="/MoJi-Monkey/2023/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React/Lane%E6%A8%A1%E5%9E%8B/">lane模型</a></h1></header><div class="post-datetag"><div class="post-date"><time class="post-time" itemprop="datePublished" title="2023-09-19 19:04:53" datetime="2023-09-19T11:04:53.000Z">2023-09-19</time></div>|<div class="post-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/MoJi-Monkey/tags/Scheduler/" rel="tag">Scheduler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/MoJi-Monkey/tags/lane/" rel="tag">lane</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/MoJi-Monkey/tags/react/" rel="tag">react</a></li></ul></div>|
<div class="post-visit"><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span>hits</span></div></div><div class="post-word-count">本文共1,467字。</div><div class="article-entry" itemprop="articleBody"><blockquote>
<p>react 为什么要从之前的 expirationTime 模型，改为 lane 模型？</p>
</blockquote>
<h2 id="React-和-Scheduler-优先级的介绍"><a href="#React-和-Scheduler-优先级的介绍" class="headerlink" title="React 和 Scheduler 优先级的介绍"></a>React 和 Scheduler 优先级的介绍</h2><p>由于react团队打算把 Scheduler独立发布，没所以在react内部，有一个粒度更细的优先级算法，这个就是lane模型。</p>
<p>在Scheduler内部，有5种优先级</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里取了31位有符号整数的最大值，意思是永远不会过期</span></span><br><span class="line"><span class="keyword">var</span> maxSigned31BitInt = <span class="number">1073741823</span>; </span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span> = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// Eventually times out</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">USER_BLOCKING_PRIORITY_TIMEOUT</span> = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">NORMAL_PRIORITY_TIMEOUT</span> = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">LOW_PRIORITY_TIMEOUT</span> = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// Never times out</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">IDLE_PRIORITY_TIMEOUT</span> = maxSigned31BitInt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>作为一个独立的包，需要考虑到通用性，Scheduler 和 React 的优先级并不共通，在React内部，有四种优先级</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactEventPriorities.new.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DiscreteEventPriority</span>: <span class="title class_">EventPriority</span> = <span class="title class_">SyncLane</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContinuousEventPriority</span>: <span class="title class_">EventPriority</span> = <span class="title class_">InputContinuousLane</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DefaultEventPriority</span>: <span class="title class_">EventPriority</span> = <span class="title class_">DefaultLane</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IdleEventPriority</span>: <span class="title class_">EventPriority</span> = <span class="title class_">IdleLane</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于React中，不同的交互对应的<strong>事件</strong>回调中产生的update会有不同的优先级，因此优先级与事件有关。因此在React内部的优先级也被称之为EventPriority</p>
<ul>
<li>DiscreteEventPriority<ul>
<li>对应离散事件，例如： click、focus、blur等时间都是离散触发的</li>
</ul>
</li>
<li>ContinuousEventPriority<ul>
<li>对应连续事件的优先级，例如：drag、mouseMove、scroll、touchMove等事件，都是连续触发的</li>
</ul>
</li>
<li>DefaultEventPriority<ul>
<li>对应默认的优先级，例如通过计时器周期性触发更新，这种情况下产生的update不属于交互产生的update，所以优先级是默认的优先级</li>
</ul>
</li>
<li>IdleEventPriority<ul>
<li>对应空闲情况的优先级</li>
</ul>
</li>
</ul>
<blockquote>
<p>在上面的代码中，可以发现，不同级别的EventPriority对应不同的Lane，这就是Lane模型</p>
</blockquote>
<h2 id="优先级转换"><a href="#优先级转换" class="headerlink" title="优先级转换"></a>优先级转换</h2><p>既然React 和Scheduler 的优先级并不互通，所以就会涉及到一个转换的问题</p>
<h3 id="1-Lane转换为EventPriority"><a href="#1-Lane转换为EventPriority" class="headerlink" title="1. Lane转换为EventPriority"></a>1. Lane转换为EventPriority</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">lanesToEventPriority</span>(<span class="params">lanes: Lanes</span>): <span class="title class_">EventPriority</span> &#123;</span><br><span class="line">    <span class="comment">// 用于分离出优先级最高的lanes</span></span><br><span class="line">  <span class="keyword">const</span> lane = <span class="title function_">getHighestPriorityLane</span>(lanes);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isHigherEventPriority</span>(<span class="title class_">DiscreteEventPriority</span>, lane)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">DiscreteEventPriority</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isHigherEventPriority</span>(<span class="title class_">ContinuousEventPriority</span>, lane)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">ContinuousEventPriority</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">includesNonIdleWork</span>(lane)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">DefaultEventPriority</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">IdleEventPriority</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-EventPriority转换为Scheduler的优先级"><a href="#2-EventPriority转换为Scheduler的优先级" class="headerlink" title="2. EventPriority转换为Scheduler的优先级"></a>2. EventPriority转换为Scheduler的优先级</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> schedulerPriorityLevel;</span><br><span class="line"><span class="keyword">switch</span> (<span class="title function_">lanesToEventPriority</span>(nextLanes)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DiscreteEventPriority</span>:</span><br><span class="line">    schedulerPriorityLevel = <span class="title class_">ImmediateSchedulerPriority</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ContinuousEventPriority</span>:</span><br><span class="line">    schedulerPriorityLevel = <span class="title class_">UserBlockingSchedulerPriority</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DefaultEventPriority</span>:</span><br><span class="line">    schedulerPriorityLevel = <span class="title class_">NormalSchedulerPriority</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IdleEventPriority</span>:</span><br><span class="line">    schedulerPriorityLevel = <span class="title class_">IdleSchedulerPriority</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">    schedulerPriorityLevel = <span class="title class_">NormalSchedulerPriority</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>假设有一个点击事件，在onClick中对应有一个回调函数来触发更新。该更新属于 <strong>DiscreteEventPriority</strong> ，经过上面两套转换规则进行转换后，最终得到的Scheduler 对应的优先级就是 <strong>ImmediateSchedulerPriority</strong></p>
<h2 id="Scheduler-的优先级转换React的优先级"><a href="#Scheduler-的优先级转换React的优先级" class="headerlink" title="Scheduler 的优先级转换React的优先级"></a>Scheduler 的优先级转换React的优先级</h2><p>相关转换的代码</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schedulerPriority = <span class="title function_">getCurrentSchedulerPriorityLevel</span>();</span><br><span class="line"><span class="keyword">switch</span> (schedulerPriority) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ImmediateSchedulerPriority</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">DiscreteEventPriority</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">UserBlockingSchedulerPriority</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">ContinuousEventPriority</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NormalSchedulerPriority</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">LowSchedulerPriority</span>:</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">DefaultEventPriority</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">IdleSchedulerPriority</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">IdleEventPriority</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">DefaultEventPriority</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在同一时间，可能存在很多的更新</p>
<ul>
<li>从众多的优先级的update中，选出一个优先级更高的<ul>
<li>本质就是排序</li>
</ul>
</li>
<li>表达 <strong>批</strong> 的概念，例如：在同一时间，可能有多个连续事件触发，但是这些连续事件的优先级都是一样的，那么就可以把这些连续事件的update放到同一个lane里面，这样就可以保证这些连续事件的update都会被执行到</li>
</ul>
<h1 id="expirationTime-模型"><a href="#expirationTime-模型" class="headerlink" title="expirationTime 模型"></a>expirationTime 模型</h1><p>react早期采用的就是expirationTime算法，这一点和Scheduler里面的设计是一致的。</p>
<p>在Scheduler中，设计了5种优先级，不同的优先级会对应不同的timeout，最终会对应不同的 expirationTime, 然后task根据expirationTime来进行任务的排序</p>
<p>早期的时候，在React中延续了这种设计， update的优先级与除法事件的当前时间以及优先级对应的延迟时间相关，这样的算法实际上是比较简单的。</p>
<p>每当进入Scheduler的时候，就会选出优先级最高的update进行调度。但这种算法在表示 <strong>批</strong> 的概念上不够灵活</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isUpdateInCludedInbatch = priorityOfUpdate &gt;= priorityOfBatch</span><br></pre></td></tr></table></figure>
<p>上面的代码中， priorityOfUpdate 表示的是当前update的优先级， priorityOfBatch代表的是批对应的优先级下限，也就是说，当前的update只要大于等于 priorityOfBatch ，就会被划分到同一批.</p>
<ul>
<li>所以没有办法将某一范围的几个优先级划为同一批</li>
</ul>
<p>根本原因是，expirationTime模型优先级算法，耦合了 <strong>优先级</strong> 和 <strong>批</strong>的概念，限制了模型的表达能力。优先级算法的本质是为update进行排序，但是expirationTime模型机在完成排序的同时，还默认的划定了 <strong>批</strong></p>
<h1 id="lane-模型"><a href="#lane-模型" class="headerlink" title="lane 模型"></a>lane 模型</h1><p>因此，基于伤处的原因，React中引入了lane模型。不管新引入什么模型，比如要保证一下两个问题得到解决：</p>
<h2 id="以优先级为依赖，对update进行一个排序"><a href="#以优先级为依赖，对update进行一个排序" class="headerlink" title="以优先级为依赖，对update进行一个排序"></a>以优先级为依赖，对update进行一个排序</h2><p>针对第一个问题，lane模型中，设置了很多的lane妹妹一个lane实际上是一个二进制来表达优先级，越低的位代表越高的优先级，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoLanes</span>: <span class="title class_">Lanes</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                          */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最高优先级</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SyncLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">InputContinuousHydrationLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*    */</span> <span class="number">0b0000000000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">InputContinuousLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*             */</span> <span class="number">0b0000000000000000000000000000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DefaultHydrationLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000000001000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DefaultLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                     */</span> <span class="number">0b0000000000000000000000000010000</span>;</span><br><span class="line"><span class="comment">// 最低优先级</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">OffscreenLane</span>: <span class="title class_">Lane</span> = <span class="comment">/*                   */</span> <span class="number">0b1000000000000000000000000000000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="表达-批的概念"><a href="#表达-批的概念" class="headerlink" title="表达 批的概念"></a>表达 <strong>批</strong>的概念</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bath = <span class="number">0</span></span><br><span class="line"><span class="comment">// 将laneA 和laneB 是不相邻的优先级</span></span><br><span class="line"><span class="keyword">const</span> laneA = <span class="number">0b0000000000000000000000001000000</span></span><br><span class="line"><span class="keyword">const</span> laneB = <span class="number">0b0000000000000000000000000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将laneA 纳入批中</span></span><br><span class="line"></span><br><span class="line">bath |= laneA</span><br><span class="line"><span class="comment">// 将laneB 纳入批中</span></span><br><span class="line">bath |= laneB</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在React中有一套粒度更细的优先级算法，这就是<strong>lane模型</strong>。 </p>
<p>这是一个基于位运算的算法，每一个lane是一个 32 bit integer， 不同的优先级对应了不同的lane，越低的位代表越高的优先级。</p>
<p>早期的React并没有使用lane模型，而是采用了基于 expirationTime 模型的算法。但这中间算法耦合了<strong>优先级</strong>和<strong>批</strong>的概念，限制了模型的表达能力。优先级算法的本质是为 update 排序，但expirationTime 模型在完成排序的同时还默认的划定了 <strong>批</strong></p>
<p>所以，使用lane模型就不存在这个问题，因为是基于位运算，所以在批的划分上会更加的灵活。</p>
</div></article><aside class="post-widget"><nav class="post-toc-wrap" id="post-toc"><h4>TOC</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#React-%E5%92%8C-Scheduler-%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="post-toc-number">1.</span> <span class="post-toc-text">React 和 Scheduler 优先级的介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%BD%AC%E6%8D%A2"><span class="post-toc-number">2.</span> <span class="post-toc-text">优先级转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-Lane%E8%BD%AC%E6%8D%A2%E4%B8%BAEventPriority"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">1. Lane转换为EventPriority</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-EventPriority%E8%BD%AC%E6%8D%A2%E4%B8%BAScheduler%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">2. EventPriority转换为Scheduler的优先级</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">案例</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Scheduler-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E8%BD%AC%E6%8D%A2React%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="post-toc-number">3.</span> <span class="post-toc-text">Scheduler 的优先级转换React的优先级</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#expirationTime-%E6%A8%A1%E5%9E%8B"><span class="post-toc-number"></span> <span class="post-toc-text">expirationTime 模型</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#lane-%E6%A8%A1%E5%9E%8B"><span class="post-toc-number"></span> <span class="post-toc-text">lane 模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%A5%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%BA%E4%BE%9D%E8%B5%96%EF%BC%8C%E5%AF%B9update%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F"><span class="post-toc-number">1.</span> <span class="post-toc-text">以优先级为依赖，对update进行一个排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%A1%A8%E8%BE%BE-%E6%89%B9%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="post-toc-number">2.</span> <span class="post-toc-text">表达 批的概念</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-number"></span> <span class="post-toc-text">总结</span></a></nav></aside></div><footer class="footer-nav"><div class="footer"><div class="back-top" id="back-top" title="Back to top"><i class="icon icon-chevron-bar-up"></i></div><span class="footer-msg"><div><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv">?</span>
PV
</span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">?</span>
UV</span></div>

Copyright &copy;
<span class="time-divide">-</span>2023
Belial.

Power by
<a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>
and
<a href="https://github.com/Cerallin/hexo-theme-yuzu" target="_blank" rel="external nofollow" title="v3.1">Theme Yuzu</a>.</span></div></footer><script>window.config = {
  url_root: '/MoJi-Monkey/',
  meta_path: 'meta.json',
};
</script>
<script src="/MoJi-Monkey/js/clipboard/clipboard.min.js"></script>


<script src="/MoJi-Monkey/js/theme.js"></script>


<script src="/MoJi-Monkey/js/index.js"></script>

<script src="/MoJi-Monkey/js/toc.js"></script>
</div><div class="search-modal" id="search-modal" data-show="false"><div class="card"><div class="card-head"><div class="search-box"><input class="search-input" id="search-input" placeholder="search"/><div class="search-button" id="search-button"><div class="icon icon-search"></div></div></div><div class="close-button"><div class="icon icon-x"></div></div></div><div class="card-body"><div class="search-count">search.total<span id="search-count-num">0</span>search result(s) in total.</div><div class="search-result" id="search-result"></div></div></div></div></body></html>